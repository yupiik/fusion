[{"lang":"en","lvl2":"Sample\nInjections\nLaunching","text":"CLI modules enables you to write simple @Command beans reusing @RootConfiguration for their parameters.\nif you don't want to set any prefix for the configuration, set the prefix in @RootConfiguration to -.\nYou can inject any simple type (classes, not lists) beans in your command through the constructor (> first parameter).\nif you need to inject a list, you can always create a bean which holds the list and inject this wrapper in your command.\nfusion-cli provides an integration with Launcher main, if you don't use it, you will have to call yourself CLIAwaiter and register an instance of Args.","title":"CLI","url":"//www.yupiik.io/fusion/fusion/cli.html"},{"lang":"en","lvl2":"Dependency\nJSON-RPC/OpenRPC to Asciidoc\nJSON-RPC/OpenRPC to OpenAPI\nJSON-RPC/OpenRPC to Postman\nFormat documentation in Asciidoc","text":"\nDocumentation module provides some tasks you can integrate with Yupiik minisite - or any other living documentation. It aims at consuming the JSON metadata generated by Fusion to convert it to a documentation content.\nThe class io.yupiik.fusion.documentation.OpenRPC2Adoc enables to convert the partial OpenRPC metadata (META-INF/fusion/jsonrpc/openrpc.json) to Asciidoc format for an easier integration in documentation.\nConfiguration:\nOpenAPI is the OpenRPC for plain old RESTful API. However it has some great tooling - SwaggerUI to not cite it.\nThe class io.yupiik.fusion.documentation.OpenRPC2OpenAPI enables to convert the partial OpenRPC metadata (META-INF/fusion/jsonrpc/openrpc.json) to OpenAPI format for an easier integration in documentation and in particular SwaggerUI.\nTo integrate it with SwaggerUI you have to register the SwaggerUI requestInterceptor which will convert the request url to the server url (which must be JSON-RPC endpoint) since the converter moves methods as path to comply to OpenAPI model:\nThe class io.yupiik.fusion.documentation.OpenRPC2Postman enables to convert the partial OpenRPC metadata (META-INF/fusion/jsonrpc/openrpc.json) to a Postman collection.\nio.yupiik.fusion.documentation.DocumentationGenerator enables to format the documentation in asciidoc.\nIf you use Yupiik tools minisite, configuration will often look like:","title":"Documentation","url":"//www.yupiik.io/fusion/fusion/documentation.html"},{"lang":"en","lvl2":"Defining a Bean without injections\nDefining a Bean with injection(s)\nCreate a bean in a custom fashion without a class\nInjection of a list/set\nListen to an event\nEmit an event\nCreate a configuration model\nCreate a JSON model\nHandle unknown JSON attributes\nDefine a custom HTTP endpoint\nDefine a JSON-RPC endpoint\nDefine a \"reactive\" JSON-RPC endpoint\nRegister OpenRPC endpoint\nStart the container\nTest with JUnit 5\nDo a fat jar with maven shade plugin","lvl3":"Example\nImplement a custom explicit Endpoint bean\nImplement a custom implicit Endpoint","text":"\nIf a bean has an injection or an event listener it will be automatically defined as a bean, but in some cases, you want to define a bean on a plain class without any injection nor event listener. For such a case, you can mark the class with @Bean:\nThis simple definition enables you to inject this bean in other beans.\nThe common use case of a framework is to get injected some bean without exactly knowing how it was created or initialized. Here is how to get an injection with Fusion framework:\ndo NOT use private fields, it is not yet supported.\nAlternatively, you can use constructor injections:\nIt can happen you need to reuse some custom factory and code the initialization of a bean. For such a case you can mark a method with @Bean. Injections can be done in the enclosing bean if needed:\nas of today, you can mark the producer method with a scope but lazy scopes (like @ApplicationScoped are not really lazy until you implement yourself the lazyness - but scope is respected, i.e. if it is @ApplicationScoped it will be a singleton).\nif the returned type implements AutoCloseable, close() will be called to destroy the bean instance(s).\ninjections of List or Set are done by resolving the parameter type of the injection.\nyou can put on the implementations (or beans) the annotation @Order to sort their position in the List - ignored for Set.\nBeans can communicate loosely between them thanks to events. The bus is synchronous and sorted using @Order annotation.\nExample of ordered event listener (default being 1000):\nlistening to Start event can enable a lazy instance (@ApplicationScoped) to be forced to be initialized.\nan event can have more parameters, other parameters will be considered as injections (but the lookup will be destroyed after the method call if it is not @ApplicationScoped)\nWhen using the Launcher provided by the Fusion, you can use the shutdown hook to call the container.close() method and send the Stop event by settings the Fusion configuration property fusion.launcher.useHook to true. The JVM catches signals to implement shutdown hooks for unexpected termination. The JVM uses SIGHUP, SIGINT, and SIGTERM to initiate the running of shutdown hooks (see https://github.com/openjdk/jdk/blob/master/src/java.base/share/man/java.md?plain=1#L817)\nTo emit an event simply inject the Emitter and send the needed event:\nCreate a configuration model\nA configuration model is a record marked with @RootConfiguration:\nThis simple configuration will read the system properties server.port, server.accessLogPattern (or environment variables SERVER_PORT, SERVER_ACCESSLOGPATTERN) to fill the values. The instance of ServerConfiguration can be injected in any bean:\nIf you want to customize the name of the property you can use @Property.\nFinally, you can register you own source of values creating a bean of type ConfigurationSource.\nList<OtherConfig> are supported, but you must set in the configuration <prefix for this list>.length to the length value of the list then the nested instances are configured using <prefix>.<index> starting at index 0. Ex: myconf.mylist.0.name=foo. Similarly, Map<String,X> are supported. For primitives, it uses properties syntax and when X is another configuration model you must use an index based notation with length property and key, value suffixes.\nHere is an example of a simple configuration model using both List and Map of properties.\nEnvironment variables (shell script):\nEnvironment variables (yaml):\nSetting system properties in java:\nCreate a JSON model\nA JSON model is a record marked with @JsonModel:\nThen simply inject the JsonMapper in any bean to read/write such a model:\nThis will match this JSON:\nAnd convert it to the following record mapping: MyModel[name=fusion, extensions={x-foo=true,boney=M}].\nyou can use the configuration entry fusion.jsonrpc.binding to change the /jsonrpc default binding. You can also set fusion.jsonrpc.forceInputStreamUsage to true to force the input to be reactive instead of using default request Reader.\nyou can review documentation page to see how to render OpenRPC as asciidoc or OpenAPI content.\nIt is possible to register an OpenRPC endpoint named openrpc to serve JSON-RPC specification:\nTo launch the application you need to start the container. It is done in two phases:\nConfigure the runtime\nLaunch the runtime.\nHere is how to do it:\nyou can also just reuse io.yupiik.fusion.framework.api.main.Launcher main which will start the default container. You can implement a custom Awaiter to not let the container shutdown immediately if you need - webserver does it by default. Finally you can also, using this launcher, inject Args to read the main arguments.\nAlternatively you can run a single container for all tests:\nFatjar are not recommended in general but can be convenient for demo or CLI applications. Here is how to do it very easily with Apache Maven shade plugin:","title":"Example","url":"//www.yupiik.io/fusion/fusion/examples.html"},{"lang":"en","lvl2":"Dependency\nUsage\nEach built-in helper data-variables\nFuture","text":"Fusion handlebars provides a light handlebars templating support.\nIt starts from HandlebarsCompiler (available as a fusion bean) which compiles a template + its helpers and partials as a Template which supports to render the template.\nData can be map of primitives (or data which have a toString()) or lists for now. It tolerates that you pass a Supplier too as map value for a lazy evaluation.\n{{each xxx} supports the following data-variables:\n@first (boolean): is the current element the first one,\n@last (boolean): is the current element the last one,\n@index (integer): 0-based index of current element.\nIf the xxx variable is not a Collection but a Map, the additional @key and @value data-variables are available.\nTechnically it is possible to go further but it has to be proven useful, here are some ideas:\nSupport records (potentially POJO but immutability would be a plus) as model,\nSupport CompletionStage as model - requires to return a CompletionStage<String> instead but generally we can always await the model is available before the rendering and making helpers promise friendly has other drawbacks,\nSupport to precompile the template at build time, this can use an API like public interface MyTemplates { @HandleBars(template = \"myresource.handlebars\") String myResource(MyRecordDataOrMap data); } and fusion processor would generate an implementation of this type which would be a bean. This option requires to override most of *Part implementations but is very feasible,\nSupport more this cases, right now a few cases don't support this keyword,\nSupport lookup, this is built-in in handlebars but has the drawback to rely on lookup at runtimes, maybe something to not add,\nSupport streaming? If the output can be huge - assuming we support later Iterable or Stream for example - then we can replace the output String by a InputStream or a Publisher<ByteBuffer> for ex,\nCorrect whitespace control ( https://handlebarsjs.com/guide/expressions.html#subexpressions),\nElse support (in if blocks),\n...","title":"Fusion Handlebars","url":"//www.yupiik.io/fusion/fusion/handlebars.html"},{"lang":"en","lvl2":"What an operator is\nDependency\nConfiguration\nBuild a custom operator\nTIP","lvl3":"Creating a container for our operator\nDeploy your operator","text":"\nAn operator is generally a process handling Custom Resource Definition (CRD). In other words, it is a process handling custom descriptor types.\nA common example is to handle an API kind of descriptor instead of creating a ConfigMap plus a Deployemnt plus an Ingress plus a LoadBalancer:\nas for Yupiik Bundlebee, we prefer to use descriptors in JSON since it is easier to work with and less error prone.\nOnce deployed, the operator will be responsible to convert the spec in Kubernetes default objects (Deployment, ...). On the user side you can manage your API with any Kubernetes API client, including kubectl: kubectl get -n my-apps my-apis.\nThe operator default runtime has these default configuration keys:\noperator.await (OPERATOR_AWAIT) (default: true): Should operator await process termination, keep it true until you embed it.\noperator.event-thread-count (OPERATOR_EVENT_THREAD_COUNT) (default: 1): How many threads are handling events, take care that more than one require a specific concurrency handling.\noperator.kubernetes.certificates (OPERATOR_KUBERNETES_CERTIFICATES) (default: \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\"): Kubernetes certificate to connect to its API.\noperator.kubernetes.master (OPERATOR_KUBERNETES_MASTER) (default: java.util.Optional.ofNullable(System.getenv(\"KUBERNETES_SERVICE_HOST\")).map(host -> \"https://\" + host + ':' + java.util.Optional.ofNullable(System.getenv(\"KUBERNETES_SERVICE_PORT\")).orElse(\"443\")).orElse(null)): The kubernetes API base URL.\noperator.kubernetes.tls-skip (OPERATOR_KUBERNETES_TLS_SKIP) (default: false): Should TLS validations be skipped.\noperator.kubernetes.token (OPERATOR_KUBERNETES_TOKEN) (default: \"/var/run/secrets/kubernetes.io/serviceaccount/token\"): Kubernetes token (service account).\noperator.probe-port (OPERATOR_PROBE_PORT) (default: 8081): Server for healthchecks, set to a negative value to disable (when embedded for ex).\noperator.use-bookmarks (OPERATOR_USE_BOOKMARKS) (default: true): If true, BOOKMARK events are enabled.\nAs soon as you imported fusion-kubernetes-operator-base module (and as any Fusion application you can use fusion-api and build dependencies fusion-processor and fusion-build-api) you have to implement the Operator API and define your custom resource model (spec).\nThis API enables you to get current state of the descriptors (it starts by a \"find all\") and listen for any change (add, modify, delete hooks).\nthese is an Operator.Base class which enables to ease the configuration and a BulkingOperator which gives you events by bulk instead of one by one to bulk changes and reduce the work you do with the API when needed.\nHere is an operator just logging custom resource events - the other actions are generally custom:\nYou can create the image of your container as you want but the easiest is to use jib or Geronimo Arthur maven plugins.\nHere is how with JIB I can convert my module to a container:\nit is recommended to add the following dependency to your pom:\nand then in your jvmFlags add (to get logs in JSON):\nOnce done, you can run mvn package jib:build to push the image to the remote registry if set or mvn package jib:dockerBuild to push it to your docker daemon.\nBefore deploying your operator, you need to define your CRD, this is done in a yaml or JSON file and defines the API your operator will support.\nfor a full reference, refer to Kubernetes documentation.\nHere is an example for the API CRD we took as an example:\nOnce this descriptor applied (using mvn bundlebee:apply or kubectl apply), you can deploy the operator itself. The operator needs a service account with the needed roles of what the operator uses from the Kubernetes API. It is at least the permissions to get, list, watch the custom resources we just defined but it is also generally the permissions to create/update/delete a deployment/configmap/....\nyou can use ClusterRole but it is good to ensure it is namespaces to avoid the operator to break something in other namespaces - at least while testing or until your operator is cluster wide (like an observability one for ex).\nthis part is mainly to give you an entry point but it will need customization depending your case.\nThe service account part will be composed of:\nA service account we will use in the controller,\nA role (list of roles actually) giving the permission to the kubernetes client to do what is needed,\nA role binding to associate the role to the service account.\nHere is the service account:\nyou can need to create one per namespace you target - or let your operator doing it using another service account but this is out of scope of this part.\nThe role will require at minimum the list and watch permissions on your custom resource:\nFinally, the role binding associates both:\nThe controller can be a deployment or statefulset if you need to store some state:\nIf you want to deploy this CRD with bundlebee, we recommend you to create:\nAn alveolus (deployable) for the CRD itseld,\nAn alveolus for the controller stack (with service account),\nAn alveolus for both.\nHere is what it can look like in your manifest.json assuming you have previous resources named as the snippets and put in kubernetes folder:\nYou can disable, in the configuration, the probes, this is to ease to embed the operator stack in a custom fusion-http-server based module which will implement the probes itself.","title":"Fusion Kubernetes Operator Base","url":"//www.yupiik.io/fusion/fusion/kubernetes-operator.html"},{"lang":"en","lvl2":"Example\nRunner flavors\nTesting a Launcher application\nUtilities","lvl3":"TestClient\nBefore/After method task","text":"Fusion Testing provides a way to start/stop a container for your tests and get injections in your test classes through method parameters or fields (still marked with @Fusion).\nThere are two runner flavors:\nFusionSupport which starts and stops the container per test class,\nMonoFusionSupport which starts and stops the container per JVM - faster but does not isolate all classes.\nusing a custom JUnit 5 Extension where you set system properties in a static block, you can configure the container before it starts. It is recommended to combine it in a custom annotation to control the ordering and ease the usage:\nThen simply replace fusion annotation by MyAppSupport.\nAlternatively you can register a test ConfigurationSource bean if you prefer but this extension option enables to also start global services like dependencies mock or a database.\nNote that if you need to exclude some module from the discovery (which uses ServiceLoader), mono extension readsyupiik.fusion.mono.modules.discovery.excluded system property which takes a comma separated list of fully qualified names.\nParticularly for CLI applications (using an Launcher and an Awaiter getting Args injected for example), you can use @FusionCLITest as a replacement of @Test. It will enable you to get an automatic execution of Launcher based on the annotation args value and to get injected Stdout and Stderr to validate the outputs.\nargs are made available to Configuration thanks a dedicated ConfigurationSource which supports these style of arguments (all leading to foo=bar mapping): --foo bar, -foo bar, foo bar, --foo=bar, -foo=bar, foo=bar. A particular arg starting by fusion-properties will be replaced by loading its value (as Properties, it can be inline or a file path - preferred).\nAdditionally to the main container friendly extensions, fusion-testing also provides a few utilities to ease writing tests.\nTestClient is a bean which is active when you use fusion-json at least and likely fusion-http-server.\nIt autoconfigures the base URI of the server - even when port is set to 0 (random) and enables to use HttpClient like API with:\nLogging of the request/response (uses fusion-httpclient is present),\nHides exception handling (synchronous API, aka send) to simplify code writing in tests,\nProvide jsonRpc JUnit5 integration to ease JSON-RPC tests.\nJUnit5 has @BeforeEach/@AfterEach callbacks but they are not per methods and related to the class - state - more then the test itself. It is also not directly related to fusion IoC beans.\nTo solve that pitfall, @Task enables to reference some code - task - which can be a fusion bean or not and call it before or after a test method execution.\nHere is how it can look like:\n@Task(value) must implement Task.Supplier which can be a java Supplier<T> - which, for BEFORE tasks will enable to inject some state as parameter referencing the bean class, or a Runnable - mainly for AFTER tasks.\nHere is a sample BEFORE task:\nAn after task will often be like:\nWhat is interesting is that, since tasks are beans, you can use an @ApplicationScoped bean to link both before/after tasks and for example store the before identifiers to delete in the after phase.","title":"Fusion Testing","url":"//www.yupiik.io/fusion/fusion/testing.html"},{"lang":"en","text":"","title":"Fusion documentation","url":"//www.yupiik.io/fusion/index.html"},{"lang":"en","lvl2":"Core Values\nFeatures\nLimitations\nSetup\nExtension Modules","lvl3":"No interceptor support","text":"\nFor cloud applications, being the most reactive possible is a key criteria so Fusion chose to:\nBe build time oriented: only delegate to runtime the bean resolution (to enable dynamic module aggregation) and not the bean and model discovery nor proxy generation,\nStay flexible: even if the model is generated at build time you can generally still customize it by removing a bean and adding your own one,\nBe native friendly: some applications need to be native to start very fast and bypass the classloading and a bunch of JVM init, for that purpose we ensure the framework is GraalVM friendly - using Apache Geronimo Arthur or not.\nField/constructor injections\nDefault scope (@DefaultScoped) is to create an instance per lookup/injection\nApplication scope (@ApplicationScoped) creates an instance per container and instantiates it lazily (at first call)\nStart/Stop events are fired with container related lifecycle hooks,\nLifecycle: @Init/@Destroy to react to the bean lifecycle,\nOptional<MyClass> injections,\nBasic cloud friendly configuration ,\nAdding fusion-json module, you can get JSON records mapping support without reflection,\nAdding fusion-http-server module, you get an Apache Tomcat abstraction enabling to write any HTTP endpoint in an efficient and GraalVM friendly manner,\nAdding `fusion-testing` module, you get some JUnit 5 integration enabling to test easily your code.\nAdding `fusion-cli` module, you can generate simple CLI applications just writing commands.\nyou can find examples on the examples page.\nSince some years we got used to see declarative interceptors (annotations) like in this snippet:\nThese are great and the container is actually linking the annotation to an implementation (a bean in general) which intercepts the call. This is not bad but has some design pitfalls:\nMost interceptors will use parameters and for such a generic approach to work, it needs an Object[] (or List) of parameters. This is really not fast (it requires to allocate an array for that purpose).\nIt requires to know and understand the rules between class interceptors, method interceptors, appending/overriding when relevant plus the same with parent classes. All that can quickly become complex.\nIt is often static: once put on a method disabling an interceptor requires the underlying library to be able to do that or to use some advanced customization at startup to do it.\nFor these reasons, we think that we don't need an interceptor solution in Fusion framework but we don't say the underlying feature is pointless, not at all. However, thanks to a more modern programming style, we can use a more functional approach to solve the same problem. Therefore, previous example would rather become:\nThe big advantage is you can use some static utility if you want but also rely on beans and even combine more efficiently interceptions in a custom and configurable fashion:\ncan become:\nIf you compare the case with parameters it is way more efficient in general since you just do a standard parameter passing call:\ngoing with this solution can, however, get the chaining lambda pitfall (a.k.a. callback hell in JavaScript), to solve this one we encourage you to ensure your \"interceptor\" can be chained properly using the same kind of callback.\nHere is an example (the important part is more the signature than the fact it is a static method or a bean method):\nThanks this definition which commonly agreed to use Supplier<T> as the intercepted call and the fact interceptor methods return a call and not execute it directly, you can chain them more easily:\nIf you want to go further you can use a Stream to represent that. Now an interceptor is a Function<Supplier<T>, Supplier<T>> so if you define the list of interceptors in a Stream, then you can just reduce them using the business function/logic as identity to have the actual invocation and execute it. Only detail to take care: ensure to reverse the stream to call the interceptor in order:\nThis is what the class io.yupiik.fusion.framework.api.composable.Wraps does.\nLast tip: you interceptor can work with CompletionStage to add some behavior before/after the call even if the result is not computed synchronously ;).\nthese are limitations as of today, none are technically strong limitations we can't fix at a later point if desired.\nA no-arg constructor must be available for any class bean,\nIf a method producer bean is AutoCloseable then it will be automatically closed,\nEvent methods can not be package scope if the enclosing bean uses a subclass proxy (like @ApplicationScoped context),\nConstructor injections are supported but for proxied scopes (@ApplicationScoped for ex) it requires a default no-arg constructor (in scope protected or public) in the class (if not existing the instantiation constructor will be called with null parameters),\nEvent bus listeners can only have the event as method parameter,\nOnly classes are supported exception for method producers which can return a ParameterizedType (ex: List<String>) but injections must exactly match this type and List/Set injections are handled by looking up all beans matching the parameter.\nSee setup page to see how to get your project started.","title":"Getting Started","url":"//www.yupiik.io/fusion/fusion/index.html"},{"lang":"en","text":"To convert your application to a native binary - assuming your dependencies are native friendly like Fusion framework, you can use Apache Geronimo Arthur maven plugin.\nAssuming you use this main for example:\nYou can just add this plugin:\nAnd run mvn package arthur:native-image and you will get your binary in target/.\nif you want a JUL implementation which is GraalVM friendly you can use yupiik Logging (yupiik-logging-jul dependency concretely which works smoothly with GraalVM and enables a runtime system property logging control) and configure it in Arthur Maven Plugin (or GraalVM native-image) using:","title":"GraalVM","url":"//www.yupiik.io/fusion/fusion/graalvm.html"},{"lang":"en","lvl2":"Request Listeners\nKubernetes client","lvl3":"Default Listeners\nSample usage\n(Open) Tracing","text":"Fusion HTTP Client is based on java.net.http.HttpClient. It is configured with ExtendedHttpClientConfiguration which enables to:\n- optionally provide a configured HttpClient instance - otherwise the default JVM one is used, - optionally provide a set of RequestListeners which listen for requests.\nRequest listener is a callback triggered before and after each request. It enables to store data before the requests in the caller context and execute some callback once the request is finished. To pass data between both steps (since the request can be asynchronous or not) it uses a State which can hold any data the listener needs.\nif you write custom listeners (to add OpenTracing capabilities for example), you can make them implement AutoCloseable and when closing the HTTP client the method will be called automatically.\nThis listener is pretty straight forward, if the request does not have a timeout, it sets it to the default one configured in the listener. It enables to enforce a global timeout to all requests.\nThis listener enforce a custom user-agent value. It defaults to chrome one.\nThis listener enables to force all exchanges to be logged.\nThis listener wraps another listener to filter the calls to before/after callbacks either based on the request or on the response. Can be useful to ignore some data (for example to only capture errors in HARDumperListener).\nfor ignoredPaths you can use the syntax regex:<java regex> to match more than an exact path at once.\nThis listener enables to capture a HAR dump of all exchanges which went through the client. It can be very useful to generate some test data you replay with a HAR server in a test or a demo environment.\nIt comes with its companion HARHttpClient which enables to replay a HAR without actually doing the requests.\na sibling listener called NDJSONDumperListener exists and allows to log each entry in a ND-JSON output (better in case of error but not standard). It can be combined to NDJSONHttpClient to replay captured requests (in order).\nthe HttpClient companions of these \"capture\" listeners must be used in sequential order (until you know you can parallelize them all) because there is no matching logic as of today of requests/responses to enable a wider reuse of captures.\nthis is not in the same module, you must add fusion-tracing module to get this feature.\ntracing module provides a Tomcat valve you can set up on your web container to add tracing capabilities to your Tomcat:\nthe accumulator should generally be closed if you reuse AccumulatingSpanCollector. You can combine it with ZipkinFlusher or OpenTelemetryFlusher to flush to a zipkin collector v2.\nkubernetes-client modules providers a HTTP Client already configured for Kubernetes in cluster connection (from a POD). This will typically be used from an operator or cloud native application to call Kubernetes API using a plain and very light HTTP Client from the JVM.\nindeed you can combine it with the enhanced HTTP Client configuring it in the KubernetesClientConfiguration. However, it is recommended to do it using setClientWrapper on the configuration and pass the automatically created client to ExtendedHttpClientConfiguration.setDelegateto avoid to have to handle the SSLContext yourself.\nUsage:\nas you can see, there is no need to pass the token to the request, it is done under the hood by the KubernetesClient. The other important note is that https://kubernetes.api is automatically replaced by the conf.getMaster() value. This enables your code to stay more straight forward in general but if you pass them, the client will handle it properly too.","title":"HTTP Client","url":"//www.yupiik.io/fusion/fusion/http-client.html"},{"lang":"en","lvl2":"Dependency\nUsage\nConfiguration\nHigh level API\n(Open) Tracing","text":"\nHTTP server module provides an abstraction over an Apache Tomcat server.\nannotations - design API - is in fusion-build-api and is only useful at build time.\nset tomcat-catalina in scope runtime to avoid to show the internal API if you don't need them, will also avoid to let your IDE complete javakarta.* transitive dependencies of tomcat.\nBy default, if you use Fusion IoC, the webservice will be started. You can customize the configuration listening for WebServer.Configuration event.\nDefining an endpoint can be done creating an Endpoint bean and implementing the matcher (matches) and handler which will return a Response thanks the builder:\nMost of the configuration can be customized using an event listener on WebServer.Configuration and unwrapping the instance as a TomcatWebServerConfiguration you have access to a full Tomcat server customization (HTTP/2.0, WebSocket and so on).\nHowever, there are a few system properties/environment variables (uppercased and with underscores instead of dots) you can set:\nTo skip the initialization of the server at startup: fusion.http-server.start=[true|false]. This can be useful to not start the server in tests for example,\nTo set the HTTP port to use: fusion.http-server.port=<port>, note that setting 0 will make the port random and you can inject WebServer.Configuration to read its value,\nTo set the host to use: fusion.http-server.host=<host>,\nTo set the access log pattern to use: fusion.http-server.accessLogPattern=<...>, see Tomcat documentation for pattern details,\nTo set the webapp directory: fusion.http-server.base=/path/to/www. It can be useful to serve static websites if you configure the right servlets,\nTo set the fusion default servlet mapping: fusion.http-server.fusionServletMapping=/. It can be useful if you want to bind it to a subcontext to use standard servlets for other things like serving base directory,\nTo set if UTF-8 is enforced (default) or not over the requests/responses: fusion.http-server.utf8Setup=true.\nFinally, you can also set by default the deployment of a monitoring server (for health checks or metrics depending your application). This is done setting fusion.http-server.monitoring.enabled to true, optionally fusion.http-server.monitoring.port to something else than 8081. The deployed endpoints in this context will be the MonitoringEndpoint bean instances.\nHere is a sample MonitoringEndpoint:\nThe first option to define an endpoint as a bean - automatically picked - is to use Endpoint.of API:\nThe alternative is to use @HttpMatcher API:\nif your endpoint is fully synchronous you can drop the CompletionStage wrapper: public CompletionStage<Response> myGreetingEndpoint();. You can also pass as first parameter a Request parameter.\nfusion-tracing module provides a Tomcat valve you can set up on your web container to add tracing capabilities to your Tomcat:\nif you reuse AccumulatingSpanCollector, it is automatically closed with the valve \"stop\" phase. You can combine the accumulator with ZipkinFlusher or OpenTelemetryFlusher onFlush implementation to flush to a zipkin collector v2.","title":"HTTP Server","url":"//www.yupiik.io/fusion/fusion/http-server.html"},{"lang":"en","lvl2":"Runtime Dependency\nExample\nEnums\nJSON-Pointer and JSON-Patch\nJson Schema Validator\nPretty mapper","text":"Fusion JSON proposes a JsonMapper API which intends to support record models.\nHere the supported features list:\nModels must be records or List<X> of a supported type, or a Map<String, X> of a supported type\nString, BigDecimal (represented as string in JSON but incoming data can be a number), {b,B}oolean, {d,D}ouble, int/Integer, {l,L}ong, OffsetDateTime, ZonedDateTime, LocalDate, LocalDateTime\nGeneric mapper is supported, it will bind Object as a Map<String, Object> values being String for JSON strings, BigDecimal for JSON numbers, another Map<String, Object> for JSON objects and List<Object> for JSON lists,\nA simple post processor prettifier (takes a JSON as input and formats it). It is used decorating the default JsonMapper: io.yupiik.fusion.json.pretty.PrettyJsonMapper,\nThe Fusion annotation processor will generate the JSON \"codecs\" from the code when a record is marked with @JsonModel, the codec will be reflection free,\nYou can customize the attribute names using @JsonProperty on the record members,\nYou can map all unknown attributes in a Map<String, Object> member marked with @JsonOthers annotation.\nstatic model (annotations) are in fusion-build-api which is a provided bundle - build time only.\nTo modelise the flow you just have to define a record marked with @JsonModel:\nBigDecimal is supported but avoid to use toBigInteger() or scale related methods without size validation due to java implementation.\nThen read/write data using JsonMapper:\nEnumerations (de)serialization behavior can be customized by using some specific methods:\nJSON-Pointer ( https://datatracker.ietf.org/doc/html/rfc6901) and JSON-Patch ( https://www.rfc-editor.org/rfc/rfc6902.html) are available for generic types today (ie you type as Object the serialized/deserialized instances to use Map<String, Object> and List<Object> as JSON-Object/JSON-Array).\nTo use them, rely on GenericJsonPointer and GenericJsonPatch classes:\nThe Json Schema Validator can be used to validate a json content according to a json-schema ( https://json-schema.org/understanding-json-schema/reference).\nIf the validation failed, the result object of the apply method will contain a list of the messages for each validation check:\nFusion provide a json pretty mapper to print a json string.","title":"JSON","url":"//www.yupiik.io/fusion/fusion/json.html"},{"lang":"en","lvl2":"Runtime Dependency\nConfiguration\nUsage\nIntegration with web layer","text":"The JWT module intend to parse and validate a JWT just using fusion-json dependency and the JVM.\nMost of the time you will use an API gateway to do that but for advanced business validations or lighter architectures, it can make sense to do it in the application.\nThe configuration is a JwtValidationConfiguration (you have to integrate it in your application configuration or reuse the jwt named one you can inject). Here are the subkeys:\njwt-signer.algorithm (JWT_SIGNER_ALGORITHM) (default: \"RS256\"): Default JWT alg value if no keys is set (mainly useful for Hmac case).\njwt-signer.expRequired (JWT_SIGNER_EXPREQUIRED) (default: true): Is exp (expiry) required.\njwt-signer.expValidity (JWT_SIGNER_EXPVALIDITY) (default: 0): Is exp is required the validity used in milliseconds.\njwt-signer.iatRequired (JWT_SIGNER_IATREQUIRED) (default: false): Is iat (issued at) required.\njwt-signer.issuer (JWT_SIGNER_ISSUER)*: JWT issuer.\njwt-signer.key (JWT_SIGNER_KEY)*: Private key.\njwt-signer.kid (JWT_SIGNER_KID) (default: \"k001\"): KID header kid.\njwt-signer.nbfRequired (JWT_SIGNER_NBFREQUIRED) (default: false): Is nbf (not before) required.\njwt.algo (JWT_ALGO) (default: \"RS256\"): Default JWT alg value if no keys is set (mainly useful for Hmac case).\njwt.expRequired (JWT_EXPREQUIRED) (default: true): Is exp (expiry) validation required of can it be skipped if claim is missing.\njwt.iatRequired (JWT_IATREQUIRED) (default: false): Is iat (issued at) validation required of can it be skipped if claim is missing.\njwt.issuer (JWT_ISSUER): JWT issuer, validation is ignored if null.\njwt.jtiRequired (JWT_JTIREQUIRED) (default: true): Is jta (expiry) validation required of can it be skipped if claim is missing.\njwt.key (JWT_KEY)*: Default public key to use to validate the incoming JWT if no keys is set else kid is matched against the keys set (mainly useful for Hmac case which can't be in jwk_uri).\njwt.keys.$index.alg (JWT_KEYS_INDEX_ALG): -.\njwt.keys.$index.crv (JWT_KEYS_INDEX_CRV): -.\njwt.keys.$index.e (JWT_KEYS_INDEX_E): -.\njwt.keys.$index.kid (JWT_KEYS_INDEX_KID): -.\njwt.keys.$index.kty (JWT_KEYS_INDEX_KTY): -.\njwt.keys.$index.n (JWT_KEYS_INDEX_N): -.\njwt.keys.$index.use (JWT_KEYS_INDEX_USE): -.\njwt.keys.$index.x5c (JWT_KEYS_INDEX_X5C): -.\njwt.keys.$index.x (JWT_KEYS_INDEX_X): -.\njwt.keys.$index.y (JWT_KEYS_INDEX_Y): -.\njwt.nbfRequired (JWT_NBFREQUIRED) (default: false): Is nbf (not before) validation required of can it be skipped if claim is missing.\njwt.tolerance (JWT_TOLERANCE) (default: 30): Tolerance for date validation (in seconds).\nEntry point is to inject a JwtvalidatorFactory (through constructor or @Injection on a field) and create an instance of validator passing a JwtValidatorConfiguration which sets the JWT algorithm, issuer, key etc...\nFor JSON-RPC module, the easiest integration is to observe io.yupiik.fusion.jsonrpc.event.BeforeRequest event and plug your validation logic there (claim checks for example):\nif you don't want to redefine the configuration nor the validator, you can inject io.yupiik.fusion.jwt.bean.DefaultJwtValidator directly.","title":"JWT validation","url":"//www.yupiik.io/fusion/fusion/jwt.html"},{"lang":"en","lvl2":"Observability\nHTTP Server\nHealth checks\nMetrics","text":"\nObservability stack is composed of these primitives:\n: it enables to configure your logging using system properties even using GraalVM native-image. It is also a good companion for container based deployments (Kubernetes) since you can switch very easily logging to JSON (-Djava.util.logging.manager=io.yupiik.logging.jul.YupiikLogManager -Dio.yupiik.logging.jul.handler.StandardHandler.formatter=json).\nHealthcheck(s): this is the capacity to test through HTTP the server state, mainly used by Kubernetes to check if the application is ready (can get traffic) and if it is in a broken state (pod should be killed and restarted for ex.). It is part of fusion-observability module.\nMetrics: often coupled to prometheus or opentelemetry, it enables to collect metrics (think time series) about your application. It can be technical (CPU usage for ex.) or business (number of downloads, number of open pages by session). It is part of fusion-observability module.\nTracing: this is the ability to trace a business request (a trace) end to end through all the system. Main collectors/UI are Jaegger and Zipkin. Fusion supports that through its fusion-tracing module (see HTTP Server or HTTP Client modules).\nBy default, observability module adds another web server for observability purposes. Default port is 8181, but you can set fusion.observability.server.port configuration (system property, environment variable using underscores and uppercasing it) to override it.\nThe goal to not reuse the same server is to not have to secure this one (it will stay an internal port in your cluster/infrastructure). Since some Kubernetes tooling does not like adding headers to gather the data (prometheus for ex.) it is a good compromise.\nA health check implements io.yupiik.fusion.observability.health.HealthCheck API.\nThen the observability server will expose a /health endpoint which will return an HTTP 200 if all health checks are successful and an HTTP 503 if there is at least one failure.\nIf you need to distinguish between health check types, you can implement type() method and return something different from live.\nThen you can call the particular endpoints using /health?type=<my type>. To get the live checks, for example, use /health?type=live. Without type query parameter, all checks are executed.\nMetrics exposes an endpoint /metrics on observability server which renders the openmetrics stored in io.yupiik.fusion.observability.metrics.MetricsRegistry.\nIt supports Gauge and Counter metric types.\nHere is a common way to use it in your application:\nyou can unregister your counter on the registry if it is a short live counter (to use with a session for example), it will then no more be available but using that with prometheus, you have no guarantee it will be polled, so it can be neat to delay the un-registration until next polling. Gauge can make it easy using registerReadOnlyGauge since you then pass a LongSupplier you control.","title":"Observability","url":"//www.yupiik.io/fusion/fusion/observability.html"},{"lang":"en","lvl2":"Project definition\nConfiguration\nEntity\nQuerying","lvl3":"Default configuration\nOperation on entity\nCRUD\nCustom queries\nAdvanced queries\nGet rid of thread local usage","text":"\nThe Fusion Persistence module provides capabilities to deal with common database operations.\neven if the default Database is the more tempting thanks its simplicity, we encourage you to go with the ContextLessDatabase instead which has a way better design, in particular on recent JVM.\nFirst you need to add the fusion-persistence module in your pom.xml dependencies section:\nannotations - design API - is in fusion-build-api and is only useful at build time.\nYou need to add the tomcat-jdbc dependency to use TomcatDataSource pool:\nYou can find the full available properties to configure the pool here\nDefault configuration can implicitly configure a datasource if you set fusion.persistence.datasource.url value in system properties or environment variables (it uses io.yupiik.fusion.framework.api.configuration.Configuration).\nAll keys have fusion.persistence.datasource. prefix and follow org.apache.tomcat:tomcat-jdbc configuration (see https://tomcat.apache.org/tomcat-10.1-doc/jdbc-pool.html).\nHere are the available keys:\nfusion.persistence.datasource.forceReadOnly (should setReadOnly be called on .read() invocations)\nthis (implicit) datasource requires to define its bounds/transactions calling read or write wrapper, you can inject TomcatDataSource to have these methods.\nFusion support java record for database entity definition.\nSome hooks are available and can be added in the entity record directly:\nfusion-persistence in container mode (default) enables to pass injection parameters to callbacks which can ease the wiring for auditing or transversal features relying on services.\nIt's very simple to execute common action, you just need to inject the database and use it with the entity.\nFusion database provide common in-house CRUD operations.\nYou can use custom SQL queries by using the entity model from the database helper:\nFor advanced queries you can use a virtual table (it is a plain table but the @Table annotation is ignored) which would be used as project based on query aliases:\nwith JoinModel being something like:\nOr you can also use Entity binder capacity:\nMost of Database API relies on an implicit connection given from the DataSource. All these implementations rely on ThreadLocal to handle properly transactions (until you just do CRUD).\nTo avoid that, we recommend you to use ContextLessDatabase instead. It is exactly the same API except it takes a Connection as parameter replacing the ThreadLocal:\nThe big advantage is when used with read() or write() connection provider wrappers:\nWith this pattern no more need of any ThreadLocal. You can rely on TransactionManager to ease the overall usage.\nIn terms of configuration, the same than for the thread local case is supported, you just need to set fusion.persistence.contextLess to true to enable the context less case and inject a plain DataSource instead of TomcatDataSource:","title":"Persistence","url":"//www.yupiik.io/fusion/fusion/persistence.html"},{"lang":"en","lvl2":"Maven","lvl3":"Simplest\nJava >=21\nIDE/Jetbrains Idea\nUse ECJ compiler (Eclipse)\nDo not expose processor in code completion","text":"\nThe framework uses three main modules:\nAPI: the runtime API, it is the runtime API, mainly resolution/look-up oriented\nBuild API: it is the API only required at build time, it is intended to be used to trigger the generation of the runtime classes using processor module,\nProcessor: it contains the magic generating most of the runtime and making the framework efficient and light.\nTherefore the project will generally get the api in scope compile, the build api in scope provided or optional and the processor either in scope provided/optional or just defined as an annotation processor in your compiler configuration.\nthe generation process assumes the annotation processor is aware of all classes, depending the tools you generate you can need to disable incremental compilation as of today to ensure all classes are seen by the generator.\nThe simplest is to just add the API (scope compile) and processor (scope provided):\nif can be sane to compile your project with maven (mvn compile or mvn process-classes) instead of relying on your IDE. This is indeed a general rule but, in this case, will enable to avoid the pitfalls of a fake incremental compilation (compiling only a few source files using the precompiled project output). This last case can lead to missing bean, you can obviously delete the target folder of your project to force your IDE to recompile but it is saner to just rely on a properly compile phase.\nJava 21 starts to warn when you use annotation processors autodiscovery. Future java versions will even disable it by default.\nFor such version, you must explicitly enable the annotation processing. One option to do that is to use this maven-compiler-plugin configuration:\nUntil you configure IDEA to use maven to compile, it can happen it compiles a single source (at least not the whole module properly like Maven by default) so the output can miss some beans. If it happens (java: java.lang.IllegalArgumentException: Unsupported type: 'com.superbiz.MyJsonModel', known models: [....] at compile time or NoClassDefFoundError/No bean matching type '...' at test/runtime for example), then just Rebuild the project, command is in Build menu (shortcut: Alt+B -> R by default).\nUltimately just drop the target/out folder if it is not about adding a file but more about removing a file (incremental support of such a change is not great as of today - but this is not specific to this project ;)).\nFor ECJ to work you need to ensure the argument -sourcepath is set in compiler configuration and import plexus-compiler-eclipse (Maven):\nA more advanced option would be to define the api in scope compile, the build API in scope provided and the processor only in maven-compiler-plugin.\nThis option is more complex in terms of configuration but has the advantage to not expose the processor in the IDE (completion).\nHere is what it can look like:\ndisabling the incremental compilation there is generally a good idea, in particular on CI but not having the processor in provided scope will make your IDE no more able to generate properly classes in general. So a better option can be to stick to previous dependencies only option (by default maven recompiles properly the module - don't set <useIncrementalCompilation>false</useIncrementalCompilation> it means do not use incremental compilation).","title":"Setup","url":"//www.yupiik.io/fusion/fusion/setup.html"}]